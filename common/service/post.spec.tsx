// Generated by CodiumAI

import { ServerResponse } from "../model/domain/response";
import { fetchPosts } from "./post";

/*
Code Analysis

Objective:
The objective of the fetchPosts function is to fetch post data from the server and pass it to the success callback function. In case of an error, the error callback function is called with the error message.

Inputs:
- success: a callback function that takes an array of PostDTO objects as input
- error: a callback function that takes a string message as input

Flow:
1. The function sends a GET request to the server using the URL_FETCH_POSTS constant.
2. The response is converted to an array of PostDTO objects.
3. The success callback function is called with the array of PostDTO objects as input.
4. In case of an error, the error callback function is called with the error message.

Outputs:
- An array of PostDTO objects is passed to the success callback function.

Additional aspects:
- The function uses the fetch API to make a GET request to the server.
- The response is converted to an array of PostDTO objects using the json() method.
- The function catches any errors that occur during the fetch request and passes the error message to the error callback function.
*/

describe("fetchPosts_function", () => {
  // Tests that the function successfully fetches post data from the server and passes it to the success callback function. tags: [happy path]
  it("test_fetch_posts_success", async () => {
    const mockSuccess = jest.fn();
    const mockError = jest.fn();
    const mockResponse = [
      {
        area: 100,
        bhks: ["1BHK"],
        actionFlat: "Rent",
        budgets: ["10k"],
        owners: true,
      },
    ];
    global.fetch = jest.fn().mockImplementation(() =>
      Promise.resolve({
        json: () => Promise.resolve(mockResponse),
      })
    );
    await fetchPosts(mockSuccess, mockError);
    expect(mockSuccess).toHaveBeenCalledWith(mockResponse);
  });

  // Tests that the function handles an empty array of post data returned by the server. tags: [edge case]
  it("test_fetch_posts_empty_response", async () => {
    const mockSuccess = jest.fn();
    const mockError = jest.fn();
    const mockResponse: ServerResponse[] = [];
    global.fetch = jest.fn().mockImplementation(() =>
      Promise.resolve({
        json: () => Promise.resolve(mockResponse),
      })
    );
    await fetchPosts(mockSuccess, mockError);
    expect(mockSuccess).toHaveBeenCalledWith(mockResponse);
  });

  // Tests that the function handles an error response returned by the server. tags: [edge case]
  it("test_fetch_posts_error_response", async () => {
    const mockSuccess = jest.fn();
    const mockError = jest.fn();
    const mockResponse = { error: "Server Error" };
    global.fetch = jest
      .fn()
      .mockImplementation(() => Promise.reject(mockResponse));
    await fetchPosts(mockSuccess, mockError);
    expect(mockError).toHaveBeenCalledWith(JSON.stringify(mockResponse));
  });

  // Tests that the function catches any errors that occur during the fetch request and passes the error message to the error callback function. tags: [behavior]
  it("test_fetch_posts_error_callback", async () => {
    const mockSuccess = jest.fn();
    const mockError = jest.fn();
    let errMsg = "error_message";
    jest.spyOn(global, "fetch").mockRejectedValueOnce(errMsg);
    await fetchPosts(mockSuccess, mockError);
    expect(mockSuccess).not.toHaveBeenCalled();
    expect(mockError).toHaveBeenCalledWith(JSON.stringify(errMsg));
  });
});
